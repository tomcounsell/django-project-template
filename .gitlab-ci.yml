stages:
  - lint
  - test
  - build
  - deploy

variables:
  POSTGRES_DB: test_db
  POSTGRES_USER: postgres
  POSTGRES_PASSWORD: postgres
  POSTGRES_HOST_AUTH_METHOD: trust
  DATABASE_URL: "postgres://postgres:postgres@postgres:5432/test_db"
  DJANGO_SETTINGS_MODULE: settings

# Cache dependencies to speed up subsequent runs
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - .pip-cache/
    - venv/
    - theme/static_src/node_modules/

# Linting job
lint:
  stage: lint
  image: python:3.12
  services:
    - postgres:14
  before_script:
    - python -m pip install --upgrade pip
    - python -m pip install --cache-dir=.pip-cache uv
    - ./requirements/install.sh dev
    - python -m pip install --cache-dir=.pip-cache black flake8 mypy django-stubs isort
  script:
    - black --check .
    - isort --check-only --profile black .
    - flake8 .
    - mypy .
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

# Security checks
security:
  stage: lint
  image: python:3.12
  before_script:
    - python -m pip install --upgrade pip
    - python -m pip install --cache-dir=.pip-cache uv
    - ./requirements/install.sh prod
    - python -m pip install --cache-dir=.pip-cache bandit safety
  script:
    - bandit -r apps/ settings/
    - safety check -r requirements/prod.txt
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

# Run tests with coverage
test:
  stage: test
  image: python:3.12
  services:
    - postgres:14
  before_script:
    - python -m pip install --upgrade pip
    - python -m pip install --cache-dir=.pip-cache uv
    - ./requirements/install.sh dev
    - python -m pip install --cache-dir=.pip-cache pytest pytest-django pytest-cov
  script:
    - python -m pytest --cov=apps --cov-report=xml
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

# Build Python package
build-python:
  stage: build
  image: python:3.12
  before_script:
    - python -m pip install --upgrade pip
    - python -m pip install --cache-dir=.pip-cache uv
    - ./requirements/install.sh prod
    - python -m pip install --cache-dir=.pip-cache build wheel
  script:
    - python -m build
  artifacts:
    paths:
      - dist/
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_TAG

# Build frontend assets
build-frontend:
  stage: build
  image: node:20
  before_script:
    - cd theme/static_src
    - npm ci
  script:
    - npm run build
  artifacts:
    paths:
      - theme/static/css/dist/
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_TAG

# Build Docker image
build-docker:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
    - if [ "$CI_COMMIT_BRANCH" = "main" ]; then docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG $CI_REGISTRY_IMAGE:latest; docker push $CI_REGISTRY_IMAGE:latest; fi
  dependencies:
    - build-python
    - build-frontend
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_TAG

# Deploy to staging
deploy-staging:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Deploying to staging environment"
    # Add deployment script for your staging environment here
    # For example, triggering a webhook to deploy the latest Docker image
    # - curl -X POST -d "{\"tag\":\"$CI_COMMIT_REF_SLUG\"}" -H "Content-Type: application/json" $STAGING_DEPLOY_WEBHOOK
  environment:
    name: staging
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# Deploy to production
deploy-production:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Deploying to production environment"
    # Add deployment script for your production environment here
    # For example, triggering a webhook to deploy a tagged Docker image
    # - curl -X POST -d "{\"tag\":\"$CI_COMMIT_TAG\"}" -H "Content-Type: application/json" $PRODUCTION_DEPLOY_WEBHOOK
  environment:
    name: production
  rules:
    - if: $CI_COMMIT_TAG