AI Application
==============

The AI application provides infrastructure for AI/LLM integrations, including safe code execution for LLM-generated Python code.

Overview
--------

The AI app consists of two main components:

1. **PydanticAI Integration** - LLM model integrations using PydanticAI
2. **Code Execution Module** - Safe execution of LLM-generated Python code

Code Execution Module
---------------------

A comprehensive, production-quality architecture for safely executing Python code generated by Large Language Models (LLMs).

.. warning::
   The RestrictedPythonSandbox included in this module is a **proof of concept only** and is NOT secure for production use. Production deployments **MUST** use OS-level isolation (E2B, gVisor, or Firecracker).

Quick Start
~~~~~~~~~~~

Basic code execution::

    from apps.ai.code_execution import CodeExecutor

    # Create executor
    executor = CodeExecutor(user_id=request.user.id)

    # Execute code
    result = executor.execute("print('Hello, World!')")

    # Check result
    if result.success:
        print(result.stdout)  # "Hello, World!"
    else:
        print(f"Error: {result.error_message}")

With execution context::

    result = executor.execute(
        code="print(f'Hello, {context[\"name\"]}!')",
        context={"name": "Alice"}
    )

Security Architecture
~~~~~~~~~~~~~~~~~~~~

The code execution module implements defense in depth with 6 security layers:

1. **Syntax Validation** - Uses ``ast.parse()`` to validate Python syntax before execution
2. **AST Security Analysis** - Scans for forbidden imports, dangerous patterns, and excessive complexity
3. **Restricted Namespace** - Limits available built-in functions (no ``open()``, ``eval()``, ``exec()``)
4. **Import Restrictions** - Whitelist-based module access (blocks ``os``, ``subprocess``, ``socket``, etc.)
5. **Resource Limits** - Enforces timeout, memory, and output size limits
6. **Output Validation** - Detects and redacts sensitive data (API keys, SSNs, credit cards, etc.)

Production Deployment
~~~~~~~~~~~~~~~~~~~~

For production use, you must implement OS-level sandboxing:

**Recommended: E2B** (for < 10k executions/day)
   - Firecracker microVM isolation
   - Fully managed service
   - <200ms startup time
   - Cost: ~$500-1000/month

**Self-hosted: gVisor** (for 10k+ executions/day)
   - Container isolation with syscall filtering
   - Requires Docker with ``runsc`` runtime
   - Cost-effective at scale

**Enterprise: Firecracker** (for 100k+ executions/day)
   - Hardware-level isolation
   - Requires dedicated infrastructure team
   - AWS Lambda architecture

See :ref:`code-execution-production` for detailed comparison and implementation guidance.

Custom Configuration
~~~~~~~~~~~~~~~~~~~

Configure resource limits and security settings::

    from apps.ai.code_execution import CodeExecutor
    from apps.ai.code_execution.sandboxes import SandboxConfig

    config = SandboxConfig(
        timeout_seconds=10,
        max_memory_mb=256,
        max_output_bytes=500_000,
        allowed_imports=("math", "json", "datetime"),
    )

    executor = CodeExecutor(
        user_id=request.user.id,
        sandbox_config=config,
        enable_ast_validation=True,
        redact_sensitive_output=True,
    )

Django Integration
~~~~~~~~~~~~~~~~~

API Endpoint example::

    from django.http import JsonResponse
    from apps.ai.code_execution import CodeExecutor

    @api_view(['POST'])
    @permission_classes([IsAuthenticated])
    def execute_code(request):
        code = request.data.get('code')

        executor = CodeExecutor(user_id=request.user.id)
        result = executor.execute(code)

        return JsonResponse({
            'success': result.success,
            'output': result.stdout,
            'error': result.error_message,
            'execution_time': result.execution_time_seconds,
        })

Models for tracking executions::

    from apps.ai.code_execution.models import CodeExecution

    # Save execution to database
    execution = CodeExecution.create_from_result(
        user=request.user,
        code=code,
        result=result,
    )
    execution.save()

Rate Limiting
~~~~~~~~~~~~~

Enforce execution quotas per user::

    from apps.ai.code_execution.models import ExecutionQuota

    quota = ExecutionQuota.get_or_create_for_user(request.user)

    if not quota.can_execute():
        return Response(
            {'error': 'Quota exceeded'},
            status=429
        )

    # Execute code...
    result = executor.execute(code)

    # Record against quota
    quota.record_execution(result)

Documentation Links
~~~~~~~~~~~~~~~~~~

Comprehensive documentation is available in the module:

* **Quick Start**: ``apps/ai/code_execution/QUICKSTART.md`` - Get started in 5 minutes
* **Complete API**: ``apps/ai/code_execution/README.md`` - Full API reference
* **Examples**: ``apps/ai/code_execution/EXAMPLES.md`` - Real-world usage patterns
* **Production Guide**: ``apps/ai/code_execution/PRODUCTION_SANDBOX_COMPARISON.md`` - Choose the right sandbox
* **Implementation Roadmap**: ``apps/ai/code_execution/ROADMAP.md`` - Phase-by-phase deployment
* **Architecture**: ``apps/ai/code_execution/IMPLEMENTATION_SUMMARY.md`` - Design deep dive
* **Security Guide**: ``docs/SAFE_LLM_CODE_EXECUTION_ARCHITECTURE.md`` - Security principles

Module Structure
~~~~~~~~~~~~~~~

The code execution module is organized as follows::

    apps/ai/code_execution/
    ├── services/
    │   └── executor.py          # Main orchestration logic
    ├── sandboxes/
    │   ├── base.py              # Sandbox interface
    │   └── restricted_python.py # Proof-of-concept sandbox
    ├── validators/
    │   ├── syntax_validator.py  # Syntax checking
    │   ├── ast_validator.py     # Security analysis
    │   └── output_validator.py  # Output sanitization
    ├── models.py                # Django models
    └── exceptions.py            # Exception hierarchy

API Reference
~~~~~~~~~~~~

.. automodule:: apps.ai.code_execution
   :members:
   :undoc-members:
   :show-inheritance:

CodeExecutor
^^^^^^^^^^^

.. autoclass:: apps.ai.code_execution.CodeExecutor
   :members:
   :undoc-members:
   :show-inheritance:

ExecutionResult
^^^^^^^^^^^^^^

.. autoclass:: apps.ai.code_execution.ExecutionResult
   :members:
   :undoc-members:
   :show-inheritance:

Exceptions
^^^^^^^^^

.. automodule:: apps.ai.code_execution.exceptions
   :members:
   :undoc-members:
   :show-inheritance:

Models
^^^^^^

.. automodule:: apps.ai.code_execution.models
   :members:
   :undoc-members:
   :show-inheritance:

Testing
~~~~~~~

Run security tests::

    # Run all security tests
    DJANGO_SETTINGS_MODULE=settings pytest apps/ai/code_execution/tests/ -v

    # Run specific test categories
    pytest apps/ai/code_execution/tests/test_security.py::TestImportRestrictions -v
    pytest apps/ai/code_execution/tests/test_security.py::TestEscapeAttempts -v

The test suite includes 30+ adversarial test cases covering:

* Import restriction validation
* Function blocking tests
* Attribute access restrictions
* Resource exhaustion prevention
* Data exfiltration detection
* Known escape attempt validation

Statistics
~~~~~~~~~~

* **Total Lines**: 14,000+
* **Documentation**: 10,000 lines
* **Implementation**: 3,500 lines
* **Tests**: 600 lines
* **Documentation-to-Code Ratio**: 2.8:1
* **Security Tests**: 30+

See Also
~~~~~~~~

* :ref:`architecture` - Overall project architecture
* :ref:`testing` - Testing conventions
* :ref:`security` - Security best practices

.. _code-execution-production:

Production Sandbox Comparison
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Detailed comparison available in ``apps/ai/code_execution/PRODUCTION_SANDBOX_COMPARISON.md``.

.. list-table:: Production Sandbox Options
   :header-rows: 1
   :widths: 20 20 20 20 20

   * - Feature
     - E2B
     - gVisor
     - Firecracker
     - Notes
   * - Security Level
     - Very High
     - High
     - Maximum
     - All production-ready
   * - Startup Time
     - <200ms
     - 200-500ms
     - 125ms
     - E2B fastest
   * - Implementation
     - 1-2 days
     - 1-2 weeks
     - 2-3 months
     - E2B quickest
   * - Management
     - Fully managed
     - Self-managed
     - Self-managed
     - E2B easiest
   * - Cost (1k/day)
     - $$
     - $
     - $$$ (dev cost)
     - gVisor most economical
   * - Cost (100k/day)
     - $$$$
     - $$
     - $
     - Firecracker at scale

**Recommendation**: Start with E2B, migrate to gVisor at scale (>10k exec/day).
